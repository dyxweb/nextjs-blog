## [CSRF](https://juejin.cn/post/6844903689702866952)
- CSRF（Cross-site request forgery）跨站请求伪造，攻击者诱导受害者进入第三方网站，在第三方网站中向被攻击网站发送跨站请求。
- 利用受害者在被攻击网站已经获取的登录凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。
- 请求的哪个网站浏览器就会将需要请求的那个网站对应的Cookie添加到请求头，而不是在哪一个网站下发起的请求就将当前网站对应的Cookie添加到请求头。
### 攻击流程
1. 受害者登录a.com，并保留了登录凭证（Cookie）。
2. 攻击者引诱受害者访问了b.com。
3. b.com向a.com发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie。
4. a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。
5. a.com以受害者的名义执行了act=xx。
6. 攻击完成，攻击者在受害者不知情的情况下冒充受害者让a.com执行了自己定义的操作。
### 攻击案例
> 登录银行系统之后点进钓鱼网站，在钓鱼网站中点击按钮请求了银行系统转账的支付接口，因为在钓鱼网站中发起的支付请求携带了银行系统登录后的登录凭证（Cookie），所以能正常调用成功支付接口。

1. 登录邮件系统后点击邮件中的钓鱼邮件，点击后跳转到一个空白页面。
2. 空白页面中有隐藏逻辑，向邮件系统发送一个请求设置(默认会携带已经登录邮件系统的登录凭证（Cookie）)，将所有的邮件默认转发到攻击者设置的一个邮箱地址。
3. 通过攻击者设置的邮箱地址获取到转发邮件的邮件信息进行信息窃取操作。
### 攻击形式
- GET类型的CSRF：通过img标签向被攻击网站发送包含受害者登录信息的跨域请求。
- POST类型的CSRF：通过自动提交的表单向被攻击网站发送包含受害者登录信息的跨域请求。
- 链接类型的CSRF：通过用户点击链接向被攻击网站发送包含受害者登录信息的跨域请求。
### 攻击特点
1. 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。
2. 攻击利用受害者在被攻击网站的登录凭证（Cookie），冒充受害者提交操作，而不是直接窃取数据。
3. 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。
4. 跨站请求可以用各种方式：图片URL、超链接、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。
### CSRF预防
> CSRF的两个特点：通常发生在第三方域名，攻击者不能获取到Cookie等信息只是冒用。针对这两个特点制定对应的预防策略。

- 阻止不明外域的访问
  1. 同源检测
  2. Samesite Cookie
- 提交时要求附加本域才能获取的信息
  1. CSRF Token
  2. 双重Cookie验证
#### 同源检测
- 在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：Origin Header，Referer Header。这两个Header在浏览器发起请求时大多数情况会自动带上，并且不能由前端自定义内容。服务器可以通过解析这两个Header中的域名，确定请求的来源域。
- 使用Origin Header确定来源域名（不包含path及query），如果Origin存在那么直接使用Origin中的字段确认来源域名是否合法就可以。
  1. IE11不会在跨站CORS请求上添加Origin标头，Referer头将仍然是唯一的标识。
  2. 在302重定向之后Origin不包含在重定向的请求中，因为Origin可能会被认为是其他来源的敏感信息。对于302重定向的情况来说都是定向到新的服务器上的URL，因此浏览器不想将Origin泄漏到新的服务器上。
- 使用Referer Header确定来源域名，如果Referer存在那么直接使用Referer中的字段确认来源域名是否合法就可以。
  1. 在浏览器环境下Referrer是浏览器自己带上的，js无法修改Rerferrer，所以是不能被伪造和篡改。
  2. 通过网关或者抓包可以修改Referrer，这是中间人攻击不属于CSRF攻击范畴，防中间人攻击用HTTPS。
  3. 黑客通过自己后台代理，请求发到黑客自己的后台，黑客后台修改Referrer再转发到攻击网址的后台，这样可以修改Referrer，但请求发送到黑客自己后台不会带上被攻击网站的Cookie，登录态校验不通过，敏感操作做不了。
- 如果Origin和Referer都不存在，建议直接进行阻止。
#### Samesite Cookie
> 设置Cookie是同站Cookie，不能作为第三方Cookie，不随着跨站请求发送，可以很大程度减少CSRF的攻击。

- Strict：表明这个Cookie在任何情况下都不能作为第三方Cookie，浏览器完全禁止第三方请求携带此Cookie。
```
Set-Cookie: CookieName=CookieValue; SameSite=Strict;
```
- Lax(默认值)：当改变了当前页面或者打开了新页面且同时是个GET请求时，浏览器允许第三方请求携带此Cookie。
```
Set-Cookie: CookieName=CookieValue; SameSite=Lax;
```
- None：请求会自动携带上Cookie。前提是必须同时设置Secure属性（Cookie只能通过HTTPS协议发送），否则无效。
```
Set-Cookie: CookieName=CookieValue; SameSite=None; Secure
```
#### CSRF Token
- 在本站发起的请求中，加一个攻击者无法获取的Token。
- Token和浏览器自动携带的Cookie不一样，是需要前端手动带上的。在服务端收到请求时，如果没有Token，就可以认为是来自恶意网站。
#### 双重Cookie验证
- 在本站发起的请求中，加一个额外的字段其值和Cookie一致。
- 攻击者没有办法获取到Cookie，只是发起请求时会自动携带。在服务端收到请求时，如果没有和Cookie值一样的额外字段，就可以认为是来自恶意网站。
#### 当前用户打开其它网站链接时告知风险，由用户自己决定是否跳转。
### XSS vs CSRF 
- XSS与CSRF最大区别在于对Cookie的使用，XSS把受害者的Cookie偷盗过来，而CSRF则是借用了受害者的Cookie。

