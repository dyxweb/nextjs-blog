## 内存泄漏和垃圾回收机制
### 内存生命周期
> JavaScript是一种高级的解释执行的编程语言，是一种属于网络的高级脚本语言。所有语言第二部分都是明确的，第一和第三部分在底层语言中是明确的。但在像 JavaScript这些高级语言中，大部分都是隐含的。

1. 分配你所需要的内存
2. 使用分配到的内存（读、写）
3. 不需要时将其释放\归还
### 内存泄漏
> 程序的运行需要内存，只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。对于持续运行的服务进程，必须及时释放不再用到的内存。否则内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。不再用到的内存没有及时释放，就叫做内存泄漏（memory leak）。

### 常见的内存泄漏
- 减少全局变量的使用
> 全局变量会一直存在于内存中，直到应用程序退出。

- 意外声明的全局变量
> 解释器会把变量name当作window的属性来创建（相当于window.name = 'dyx'）。在window对象上创建的属性，只要window本身不被清理就不会消失。这个问题很容易解决，只要在变量声明前头加上var、let 或 const 关键字即可，这样变量就会在函数执行完毕后离开作用域。

```
function setName() {
  name = 'dyx';
}
```
- 被遗忘的定时器
> 只要定时器一直运行，回调函数中引用的name变量就不会被清理，就会一直占用内存。

```
let name = 'dyx'; 
setInterval(() => {
  console.log(name); 
}, 100);
```
- 使用不当的闭包
> 这会导致分配给name的内存被泄漏。以下代码创建了一个内部闭包，只要outer函数存在就不能清理name，因为闭包一直在引用着它。假如name的内容很大（不止是一个小字符串），那可能就是个大问题了。

```
let outer = function() { 
  let name = 'dyx'; 
  return function() { 
    return name; 
  }; 
};

let closure = outer();
// 当不再需要闭包时，解除对闭包的引用
closure = null;
```
- 未清理的DOM引用
> DOM元素的生命周期正常情况下取决于是否挂载在DOM树上，当元素从DOM树上移除时，就可以被销毁回收了。但如果某个DOM元素在JS中也持有它的引用，想要彻底删除这个元素，就需要把两个引用都清除，这样才能正常回收它。

```
// 在对象中引用 DOM
var elements = {
  btn: document.getElementById('btn'),
}
function doSomeThing() {
  elements.btn.click()
}

function removeBtn() {
  // 移除 DOM 树中的 btn
  document.body.removeChild(document.getElementById('btn'));
  // 但是此时全局变量elements还是保留了对btn的引用，btn还是存在于内存中，不能被回收，需要释放js对于节点的引用elements.btn = null;
}
```
- 使用弱引用
> 在ES6中引入了WeakMap和WeakSet这两个数据结构，它们可以帮助避免内存泄漏。这些数据结构使用弱引用，当对象没有其他引用时，垃圾回收机制会自动释放它们占用的内存。使用WeakMap和WeakSet可以减少手动清除引用的工作量。

```
let weakMap = new WeakMap();
let key = {};

// 使用弱引用方式设置键值对
weakMap.set(key, "value");

// 当不再需要key对象时它会被自动回收，WeakMap中的键值对也会被清除
key = null;
```
### 垃圾回收机制
> JavaScript在创建变量（对象，字符串等）时自动进行了内存分配，并且在不使用它们时“自动”释放，释放的过程称为垃圾回收。垃圾回收机制会定期（周期性）找出那些不再用到的内存（变量）然后释放其内存，JavaScript的运行环境极大地依赖于垃圾回收机制。

### 内存空间
> JavaScript的内存空间分为栈（Stack）和堆（Heap）两部分。栈用于存储原始类型（如Number，String，Boolean，Null，Undefined，Symbol）和引用对象的内存地址，而堆用于存储引用类型的对象。

### 栈回收
> 函数调用的参数、返回地址和局部变量都存储在调用栈中。每当一个函数被调用时，都会创建一个新的栈帧，其中包含这些信息。而栈帧的回收则非常直接：一旦函数调用结束，其栈帧就会被立即移除。这种机制依赖于ESP（Extended Stack Pointer）指针，该指针始终指向栈的顶部，用于追踪哪些栈帧是活动的，哪些可以被安全回收。

```
function getName() {
  let a = 1
  let b = {
    name: 'Hello World'
  }
  function foo() {
    let c = 2
    let d = {
      name: 'Hello Javascript'
    }
  }
  foo()
}
getName()
```
### 堆回收
> 与栈回收机制相比，堆回收要复杂得多。所有的对象实例都存储在堆中。这些对象的生命周期不像栈帧那样简单明了，因此需要更复杂的机制来确定何时可以安全回收这些对象的内存。主要采用标记清除算法进行垃圾回收。该算法分为两个步骤：标记阶段，V8引擎会遍历所有的对象，标记活动对象和非活动对象；清除阶段，非活动对象所占用的内存将被回收。

```
function createObject() {
  let obj = new Object();
  obj.value = 'Hello, World!';
  return obj;
}

let myObject = createObject();  // 创建对象，分配内存
myObject = null;  // 丢弃对象，垃圾回收器现在可以回收这个对象的内存
```
### 标记清除（常用的方法）
> 垃圾回收机制在运行的时候会给存储在内存中的所有变量都加上标记（可以是任何标记方式），然后它会去掉处在环境中的变量及被环境中的变量引用的变量的标记（闭包）。而在此之后剩下的带有标记的变量被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后垃圾回收机制到下一个周期运行时，将释放这些变量的内存，回收它们所占用的空间。

### 引用计数
> 语言引擎有一张"引用表"，保存了内存里面所有资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。循环使用会有内存无法释放的情况。