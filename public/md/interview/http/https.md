## [https](https://mp.weixin.qq.com/s/I5yezHTrObblrBGAoAEGkQ)
> HTTP是明文传输，因此在传输过程中数据都有可能被第三方窃取或者篡改，也就是我们常说的中间人攻击。为了防范攻击，引入新的加密方案，即 HTTPS。HTTPS就是使用SSL/TLS协议进行加密传输。

### 为什么需要加密
> 因为http的内容是明文传输的，明文数据会经过中间代理服务器、路由器、wifi热点、通信服务运营商等多个物理节点，如果信息在传输过程中被劫持，传输的内容就完全暴露了。劫持者还可以篡改传输的信息且不被双方察觉，这就是中间人攻击。所以我们才需要对信息进行加密。

### 对称加密
> 一个密钥，它可以加密一段信息，也可以对加密后的信息进行解密。

**对称加密不可行**
> 通信双方都各自持有同一个密钥，且没有别人知道，这两方的通信安全当然是可以被保证的。然而最大的问题就是这个密钥怎么让传输的双方知晓，同时不被别人知道。如果由服务器生成一个密钥并传输给浏览器，那在这个传输过程中密钥被别人劫持了，之后他就能用密钥解开双方传输的任何内容了，所以对称加密不可行。

### 非对称加密
> 有两把密钥，通常一把叫做公钥、一把叫私钥，用公钥加密的内容必须用私钥才能解开，私钥加密的内容只有公钥能解开。

**非对称加密不可行**
> 服务器先把公钥以明文方式传输给浏览器，之后浏览器向服务器传数据前都先用这个公钥加密好再传，这条数据的安全似乎可以保障了，因为只有服务器有相应的私钥能解开公钥加密的数据。然而反过来由服务器到浏览器的这条路无法保证安全，如果服务器用它的私钥加密数据传给浏览器，那么浏览器用公钥可以解密它，而这个公钥是一开始通过明文传输给浏览器的，若这个公钥被中间人劫持到了，那他也能用该公钥解密服务器传来的信息了。

**改良的非对称加密**
> 通过一组公钥私钥，可以保证单个方向传输的安全性，可以尝试使用两组公钥私钥保证双向的数据传输安全。抛开此种方法仍有的漏洞（传递公钥的过程被中间人窃取公钥，详见下述的非对称和对称加密不可以行），HTTPS的加密依然没使用这种方案的原因是非对称加密算法非常耗时，而对称加密快很多。

- 某网站服务器拥有公钥A与对应的私钥A’；浏览器拥有公钥B与对应的私钥B’。
- 浏览器把公钥B明文传输给服务器。
- 服务器把公钥A明文给传输浏览器。
- 之后浏览器向服务器传输的内容都用公钥A加密，服务器收到后用私钥A’解密。由于只有服务器拥有私钥A’，所以能保证这条数据的安全。
- 同理，服务器向浏览器传输的内容都用公钥B加密，浏览器收到后用私钥B’解密。同上也可以保证这条数据的安全。
### 非对称加密+对称加密
- 某网站拥有用于非对称加密的公钥A、私钥A’。
- 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。
- 浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。
- 服务器拿到后用私钥A’解密得到密钥X。
- 这样双方就都拥有对称密钥X了，且别人无法知道它。之后双方所有数据都通过密钥X加密解密即可。
### 非对称加密+对称加密不可行
> 如果在数据传输过程中，中间人劫持到了数据，此时他的确无法得到浏览器生成的密钥X，这个密钥本身被公钥A加密了，只有服务器才有私钥A’解开它。但是如果中间人劫持了公钥此时后续的流程都将被中间人窃取到。非对称加密+对称加密不可行的根本原因是浏览器无法确认收到的公钥是不是网站自己的，因为公钥本身是明文传输的。

- 某网站有用于非对称加密的公钥A、私钥A’。
- 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。
- 中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B’）。
- 浏览器生成一个用于对称加密的密钥X，用公钥B（浏览器无法得知公钥被替换了）加密后传给服务器。
- 中间人劫持后用私钥B’解密得到密钥X，再用公钥A加密后传给服务器。
- 服务器拿到后用私钥A’解密得到密钥X。此时对称秘钥X已被中间人窃取，后续所有的通信都有可能被中间人窃取到。
### 如何证明浏览器收到的公钥一定是该网站的公钥
> CA机构，它是如今互联网世界正常运作的前提，而CA机构颁发的“身份证”就是数字证书，数字证书可以证明网站信息就是该网站的。

**数字证书**
> 网站在使用HTTPS前，需要向CA机构申领一份数字证书，数字证书里含有证书持有者信息、公钥信息等。服务器把证书传输给浏览器，浏览器从证书里获取公钥就行了，证书就如身份证，证明“该公钥对应该网站”。

**验证数字证书的真实性以及如何防止数字证书传递过程中被篡改**
> 把证书原本的信息生成一份“签名”，比对证书内容和签名是否一致就能判别是否被篡改。这就是数字证书的“防伪技术”，这里的“签名”被称为数字签名。原有的证书信息和签名信息共同组成了数字证书。

**数字签名的生成**
1. CA机构拥有非对称加密的私钥和公钥。
2. CA机构对证书明文数据进行hash加密(不可逆)。
3. 对hash加密后的值用私钥加密，得到数字签名。
**浏览器验证数字签名**
1. 拿到证书，得到明文数据和数字签名。
2. 用CA机构的公钥对数字签名解密（由于是浏览器信任的机构，所以浏览器保有它的公钥）。
3. 用证书里指明的hash加密算法对明文数据进行hash加密。
4. 比较第二步和第三步数据的一致性，如果一致则说明证书可信。
**中间人是否可以篡改数字证书信息**
> 假设中间人篡改了证书的原文，由于他没有CA机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名。浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信。

**中间人是否可以掉包整个证书**
> 假设有另一个网站B也拿到了CA机构认证的证书，它想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书。替换证书之后浏览器很容易就发现证书被替换了，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。

**为什么制作数字签名时需要hash一次**
- 性能问题，非对称加密效率较差，证书信息一般较长，比较耗时。而hash后得到的是固定长度的信息（比如用md5算法hash后可以得到固定的128位的值），这样加解密就快很多。
- [安全问题](crypto.stackexchange.com/a/12780)
**浏览器保有的CA机构的公钥可信性**
> 操作系统、浏览器本身会预装一些它们信任的根证书，如果其中会有CA机构的根证书，这样就可以拿到它对应的可信公钥了。实际上证书之间的认证也可以不止一层，可以A信任B，B信任C，以此类推，我们把它叫做信任链或数字证书链。也就是一连串的数字证书，由根证书为起点，透过层层信任，使终端实体证书的持有者可以获得转授的信任，以证明身份。

**每次进行HTTPS请求时都必须在SSL/TLS层进行握手传输密钥吗**
> 不用，服务器会为每个浏览器（或客户端软件）维护一个session ID，在TLS握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了。

### https加密完整过程
1. 客户端发起一个HTTPS请求，连接443端口。这个过程可以理解成是「请求公钥的过程」。
2. 服务器收到请求后，会把数字证书（证书信息和签名信息(将证书信息hash加密之后使用CA机构私钥加密)）发送给客户端。
3. 浏览器拿到证书之后会得到证书信息和签名信息，用CA机构的公钥对数字签名解密，然后使用相同的hash加密证书信息，对比公钥解密和hash加密后的信息是否一致，一致则说明证书有效。
4. 在从数字证书中安全拿到「服务器公钥」后，客户端随机生成一个「对称密钥」，使用「服务器公钥」加密这个「对称密钥」，发送给服务器。
5. 服务器通过自己的私钥(数字证书信息中公钥对应的私钥)解密，至此得到了「对称密钥」，此时两者都拥有了相同的「对称密钥」。
6. 之后客户端和服务器之间的通信都通过此对称秘钥进行加解密。
### http和https的区别
> 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全，对网站服务器进行真实身份认证。

1. HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL/TLS+HTTP） 数据传输过程是加密的，安全性较好。
2. 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。
3. HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。
4. http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。
5. HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，HTTPS 比 HTTP 要更耗费服务器资源。
### https访问http资源会被浏览器block，http请求https资源没问题。