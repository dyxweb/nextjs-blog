### 单点登录
#### 同域下的 SSO（主域名相同）
> 当百度网站存在两个相同主域名下的贴吧子系统 tieba.baidu.com 和网盘子系统 pan.baidu.com 时，以下为他们实现 SSO 的步骤：

1. 客户端：用户访问某个子系统时（例如 tieba.baidu.com），如果没有登录，则跳转至 SSO 认证中心提供的登录页面进行登录；
2. 服务端：登录认证后，服务端把登录用户的信息存储于 Session 中，并且附加在响应头的 Set-Cookie 字段中，设置 Cookie 的 Domain 为 .baidu.com ；
3. 客户端：再次发送请求时，携带主域名 Domain 下的 Cookie 给服务器，此时服务端就可以通过该 Cookie 来验证登录状态了；
#### 跨域下的 SSO（主域名不同）
> 购物网站天猫 (tmall.com) 和淘宝 (taobao.com) 中，利用CAS（Central Authentication Service）中央授权服务只需要登录其中某一个系统，另外一个系统打开后就会默认登录。

![单点登录](./img/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95.png)
1. 客户端：开始访问系统 A；
2. 系统A：发现用户未登录，重定向至 CAS 认证服务（sso.com），同时 URL 地址参数携带登录成功后回跳到系统 A 的页面链接（sso.com/login?redir…）
3. CAS认证服务：发现请求 Cookie 中没有携带登录的票据凭证（TGC），所以 CAS 认证服务判定用户处于 未登录 状态，重定向用户页面至 CAS 的登录界面，用户在 CAS 的登录页面上进行登录操作。
4. 客户端：输入用户名密码进行 CAS 系统认证；
5. CAS 认证服务：校验用户信息，并且 生成 TGC 放入自己的 Session 中，同时以 Set-Cookie 形式写入 Domain 为 sso.com 的域下 ；同时生成一个 授权令牌 ST (Service Ticket) ，然后重定向至系统 A 的地址，重定向的地址中包含生成的 ST（重定向地址：www.taobao.com?token=ST-345678）
6. 系统A：拿着 ST 向 CAS 认证服务发送请求，CAS 认证服务验证票据 (ST) 的有效性。验证成功后，系统 A 知道用户已经在 CAS 登录了（其中的 ST 可以保存到 Cookie 或者本地中），系统 A 服务器使用该票据 (ST) 创建与用户的会话，称为局部会话，返回受保护资源；
7. 客户端：开始访问系统 B；
8. 系统B：发现用户未登录，重定向至 SSO 认证服务，并将自己的地址作为参数传递，并附上在 sso.com 域下的 cookie 值是第五步生成的 TGC；
9. CAS 认证服务：CAS 认证服务中心发现用户已登录，跳转回系统 B 的地址，并附上票据 (ST)；
10. 系统B：拿到票据 (ST)，去 CAS 认证服务验证票据 (ST) 的有效性。验证成功后，客户端也可以跟系统 B 通信。
#### CAS 一般提供四个接口：
- /login：登录接口，用于登录到中央授权服务。
- /logout：登出接口，用于从中央授权服务中登出。
- /validate：用于验证用户是否登录中央授权服务。
- /serviceValidate：用于让各个 Service 验证用户是否登录中央授权服务。
### 第三方登录
1. a.com 的运营者需要在微信开放平台注册账号，并向微信申请使用微信登录功能。
2. 申请成功后，得到申请的 appid、appsecret。
3. 用户在 a.com 上选择使用微信登录。
4. 这时会跳转微信的 OAuth 授权登录，并带上 a.com 的回调地址。
5. 用户输入微信账号和密码，登录成功后，需要选择具体的授权范围，如：授权用户的头像、昵称等。
6. 授权之后，微信会根据拉起 a.com?code=123 ，这时带上了一个临时票据 code。
7. 获取 code 之后，a.com 会拿着 code 、appid、appsecret，向微信服务器申请 token，验证成功后，微信会下发一个 token。
8. 有了 token 之后，a.com 就可以凭借 token 拿到对应的微信用户头像，用户昵称等信息了。
9. a.com 提示用户登录成功，并将登录状态写入 Cooke，以作为后续访问的凭证。
### 唯一登录
> 用户只能在一个设备上登录，禁止用户重复登录。

![唯一登录](./img/%E5%94%AF%E4%B8%80%E7%99%BB%E5%BD%95.png)
- 用户在客户端 A 操作：
  1. 输入账号请求登录接口；
  2. 后端生成对应 Token 并且返回给客户端 A，并且在服务端保存一个登录状态；
  3. 客户端A 保存 Token，并且每次请求都在 header 头中携带对应的 Token；
- 用户在客户端 B 操作：
  1. 突然用户在客户端 B 上开始登录操作，我们会发现，步骤和在客户端A上面的操作几乎是一致的；
  2. 只是后端在生成新的 Token 时，要先验证登录状态，然后再生成对应新的 Token；
  3. 客户端A再操作时发现Token过期提示重新登录。
### 扫码登录
![扫码登录](./img/%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95.png)
- 待扫码阶段：
  1. PC端：打开某个网站 (如taobao.com) 或者某个 APP (如微信) 的扫码登录入口；就会携带 PC 端的设备信息向服务端发送一个获取二维码的请求；
  2. 服务端：服务器收到请求后，随机生成一个 UUID 作为二维码 ID，并将 UUID 与 PC 端的设备信息 关联起来存储在 Redis 服务器中，然后返回给 PC 端；同时设置一个过期时间，在过期后，用户登录二维码需要进行刷新重新获取。
  3. PC 端：收到二维码 ID 之后，将二维码 ID 以 二维码的形式 展示，等待移动端扫码。并且此时的 PC 端开始轮询查询二维码状态，直到登录成功。
如果移动端未扫描，那么一段时间后二维码会自动失效。
- 已扫码待确认阶段：
  1. 手机端：打开手机端对应已登录的 APP (微信或淘宝等)，开始扫描识别 PC 端展示的二维码；
移动端扫描二维码后，会自动获取到二维码 ID，并将移动端登录的信息凭证（Token）和二维码 ID 作为参数发送给服务端，此时手机必须是已登录（使用扫描登录的前提是移动端的应用为已登录状态，这样才可以共享登录态）。
  2. 服务端：
收到手机端发来的请求后，会将 Token 与二维码 ID 关联，为什么需要关联呢？因为，当我们在使用微信时，移动端退出时，PC 端也应该随之退出登录，这个关联就起到这个作用。然后会生成一个临时 Token，这个 Token 会返回给移动端，一次性 Token 用作确认时的凭证。
- 已确认阶段：
  1. 手机端：收到确认信息后，点击确认按钮，移动端携带上一步中获取的 临时 Token 发送给服务端校验；
  2. 服务端：服务端校验完成后，会更新二维码状态，并且给 PC 端生成一个 正式的 Token，后续 PC 端就是持有这个 Token 访问服务端。
  3. PC端：轮询到二维码状态为已登录状态，并且会获取到了生成的 Token，完成登录，后续访问都基于 Token 完成。
