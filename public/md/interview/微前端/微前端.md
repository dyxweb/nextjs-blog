## 微前端
### 使用微前端的场景
- 项目功能逐渐增多，代码规模庞大，导致代码维护和开发效率低下。
- 项目需要集成多个不同技术栈的模块或服务。
- 团队成员分散，各自负责开发不同的模块或服务，需要实现独立开发和部署。
- 项目需要支持独立的生命周期管理和版本控制。
- 需要实现动态加载和卸载子应用等场景。
### iframe
#### iframe优点
- iframe提供了浏览器原生的硬隔离方案，不论是样式隔离、js隔离这类问题统统都能被完美解决。
#### iframe缺点
1. 隔离性和通信复杂性：iframe本身提供了一种隔离的环境，但这也带来了通信和数据交互的复杂性。由于每个子应用都在独立的iframe中运行，它们之间的通信需要通过特定的机制，而这增加了开发和维护的复杂性。
2. 性能和加载时间：每个iframe都需要加载和渲染独立的HTML、CSS和JavaScript。这意味着在加载微前端应用时，需要同时加载多个iframe，导致额外的网络请求和页面资源占用，可能会影响性能和加载时间。
3. 样式和布局限制：iframe的内容在页面中是独立的，它们具有自己的CSS样式和布局上下文。这导致在微前端架构中难以实现全局样式的一致性，以及子应用之间的布局和交互的协调问题。例如带遮罩层的弹框居中显示的问题。
4. url不同步：浏览器刷新iframe的url状态丢失、后退前进按钮无法使用。
5. 浏览器安全性限制：由于安全策略的限制，iframe之间的跨域通信可能受到限制，特别是在涉及跨域资源访问和共享数据时。这可能导致在微前端架构中需要处理复杂的安全性问题。
### 微前端运行原理
#### 监听路由变化
- 监听hash路由：window.onhashchange。
- 监听history路由：window.onpopstate，重写pushState、replaceState通过函数重写的方式进行劫持。
#### 匹配子应用
> 监听路由的变化后拿到当前路由的路径window.location.pathname，然后根据registerMicroApps注册的子应用的activeRule获取匹配的子应用。

#### 加载子应用
> 找到当前路由匹配的子应用后可以加载这个子应用的html资源。不能给直接通过container.innerHTML = html将文本放到容器内，这样是无法显示的。浏览器处于安全考虑，放到页面上的html如果包含了js脚本，它是不会去执行js的，需要手动处理script脚本。

- 将获取到的html文本放到template DOM节点中。
- 获取所有的script脚本，script脚本分为内联脚本和外链脚本，拿到内联脚本后获取内容可以通过eval直接处理。如果是含有scr的script脚本，还需要拿到src的值，通过fetch去获取脚本。
- 执行所有的script脚本，通过eval执行脚本。
#### 渲染子应用

