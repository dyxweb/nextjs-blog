## 状态管理
### 状态
- 状态是表示组件当前状况的JS对象。在React中可以使用useState或者this.state维护组件内部状态，通过Props传递给子组件使用。
- 为了避免状态传递过程中出现混乱，React引入了“单向数据流”的理念。主要思想是组件不会改变接收的数据，只会监听数据的变化，当数据发生变化时组件会使用接收到的新值而不是修改已有的值。当组件的更新机制触发后，组件使用新的值进行重新渲染。
- 父子组件通信可以直接使用Props进行通信，深层次、兄弟组件通信需要通过Props层层传递或“状态提升”进行通信。
### 状态管理常见模式
- 状态提升：兄弟组件间是没法直接共享状态的，可以通过将状态提升到最近的祖先组件中，兄弟组件就可以通过Props传递获取状态。
- 属性下钻：将父组件的状态以属性的形式一级级传递给深层次子组件。
- Context：使用Context对于深层次子组件可以通过Context直接获取状态，不再需要通过属性下钻获取状态。
- 状态组合：某些状态可能只在应用程序的特定子树中需要。最好将状态存储在尽可能接近实际需要的位置，这有助于优化渲染行为。
### 状态管理库要解决的问题
1. 从组件树的任何地方读取存储的状态。
2. 写入存储状态的能力。
3. 提供优化渲染的机制。
4. 提供优化内存使用的机制。
5. 与并发模式的兼容性。
6. 数据的持久化。
7. 上下文丢失问题。
8. props失效问题。
9. 孤儿问题。
### React Context
- 在多层级嵌套组件的场景下，使用“属性下钻”方式进行组件通信是一件成本极高的事情，React官方提供Context用于避免一级级属性传递。
- Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。在系统中跟业务相关、会频繁变动的数据在共享时，应谨慎使用Context。
- 在React里Context是个反模式的东西，不同于redux等的细粒度响应式更新，Context的值一旦变化，所有依赖该Context的组件全部都会forceUpdate，因为 Context API并不能细粒度地分析某个组件依赖了Context里的哪个属性。
- 优点
  1. 作为React内置的hook，不需要引入第三方库；
  2. API操作还算方便。
- 缺点
  1. Context只能存储单一值，当数据量大起来时，需要使用createContext创建大量context；
  2. 直接使用的话，会有一定的性能问题：每一次对state的某个值变更，都会导致其他使用该state的组件re-render，即使没有使用该值。可以通过useMemo来解决这个问题，但是就需要一定的成本来定制一个通用的解决方案；
  3. 无法处理异步请求。对于异步的逻辑，Context API并没有提供任何API，需要自己做封装；
  4. 无法处理数据间的联动。Context API并没有提供API来生成派生状态，同样也需要自行去封装一些方法来实现。
### Redux
> Redux 遵循“单向数据流”和“不可变状态模型”的设计思想。这使得Redux的状态变化是可预测、可调试的。

- 优点
  1. 繁荣的社区，像不支持异步这种问题是有成熟的中间件可以解决的。
  2. 可扩展性高，中间件模式可以随心所欲的武装dispatch。
  3. 单一数据源且是树形结构，这让redux支持回溯，在调试上也更方便。
  4. 有成熟的开发调试工具 redux devtools。
- 缺点
  1. 陡峭的学习曲线。将副作用扔给中间件来处理，导致社区一堆中间件，学习成本陡然增加。
  2. 大量的模版代码。使用redux开发者要编写大量和业务逻辑无关的模板代码，这给开发和后期维护都带来了额外的成本。
  3. 大状态量情况下，性能较差。state更新会影响所有组件。每个action都会调用所有reducer。
  4. reducer要返回新的对象，如果更新的值层级较深，更新成本也很高。
  5. 更多的内存占用，由于采用单一数据源，所有状态存储在一个state中，当某些状态不再需要使用时，也不会被垃圾回收释放内存。
