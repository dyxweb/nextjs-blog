## diff
- React在执行render过程中会产生新的虚拟DOM，在浏览器平台下为了尽量减少DOM的创建，React会对新旧虚拟DOM进行diff算法找到它们之间的差异，尽量复用DOM从而提高性能。所以diff算法主要就是用于查找新旧虚拟DOM之间的差异。
- diff操作本身也会带来性能损耗，React文档中提到即使在最前沿的算法中，将前后两棵树完全比对的算法的复杂程度为O(n^3)，其中n是树中元素的数量。如果在React中使用了该算法，那么展示1000个元素所需要执行的计算量将在十亿的量级范围。这个开销实在是太过高昂无法接受。
### 降低算法复杂度，React的diff会预设三个限制
1. 只对同级元素进行Diff，不做跨级比较。如果一个DOM节点在前后两次更新中跨越了层级，那么React不会尝试复用它，React只会简单地考虑同层级节点的位置变换，而对于不同层级的节点，只有创建和删除操作。
2. 两个不同类型的元素会产生出不同的树。如果元素由div变为p，React会销毁div及其子孙节点，并新建p及其子孙节点。
3. 开发者可以通过key属性来告诉react哪些子元素在不同的渲染下能保持稳定。
### O(n^3) => O(n)
- 每个节点都要去和另一棵树的全部节点对比一次，这就是n了，如果找到有变化的节点，执行插入、删除、修改也是n的复杂度。所有的节点都是这样再乘以n，所以是O(n * n * n)的复杂度。
- 有了上述的限制这样只要遍历一遍，对比一下type就行了，是O(n)的复杂度，而且type变了就不再对比子节点。因为vdom中记录了关联的dom节点，执行dom的增删改也不需要遍历，是O(1)的，整体的diff算法复杂度就是O(n)的复杂度。
### diff的思路
1. 当根节点为不同类型的元素时，React会拆卸原有的树并且建立起新的树，这大大减少了Diff过程中冗余的递归操作。
2. 当对比两个相同类型的React元素时，React会保留DOM节点，仅比对及更新有改变的属性。
3. 列表形式的子元素比较，React引入了key属性。当子元素拥有key时，React使用key来匹配原有树上的子元素以及最新树上的子元素，如果key不同则会拆卸原有的 key节点并且建立起新的key节点。
### Diff算法是一种对比算法
> 对比两者是旧虚拟DOM和新虚拟DOM，对比出是哪个虚拟节点更改了，找出这个虚拟节点，并只更新这个虚拟节点所对应的真实节点，而不用更新其他数据没发生改变的节点，实现精准地更新真实DOM，进而提高效率。

- 使用虚拟DOM算法的损耗计算
> 总损耗 = 虚拟DOM增删改(与Diff算法效率有关) + 真实DOM差异增删改 + (较少的节点)排版与重绘

- 直接操作真实DOM的损耗计算
> 总损耗 = 真实DOM完全增删改 + (可能较多的节点)排版与重绘

### 视图更新流程
- 组件渲染生成一棵新的虚拟dom树(render方法)。
- 新旧虚拟dom树对比，找出变动的部分(常说的diff算法)。
- 根据改变的虚拟dom树更新到真实dom上。
### vue与react的diff比较
- vue和react的diff算法，都是忽略跨级比较，只做同级比较。
- vue和react的diff算法，两个不同类型的元素会产生出不同的树，不会尝试复用。
- vue对比节点。当节点元素相同，但是classname不同，认为是不同类型的元素，删除重建，而react认为是同类型节点，只是修改节点属性。
- vue的列表对比，采用的是两端到中间比对的方式，而react采用的是从左到右依次对比的方式。当一个集合只是把最后一个节点移到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移到第一个。


